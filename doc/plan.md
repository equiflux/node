# Equiflux Chain ç³»ç»Ÿå¼€å‘è®¡åˆ’

**é¡¹ç›®åç§°**: Equiflux Chain (Three-Layer Hybrid Consensus Protocol)  
**ç‰ˆæœ¬**: v2.0  
**åˆ¶å®šæ—¥æœŸ**: 2025å¹´1æœˆ  
**åŸºäºæŠ€æœ¯æ–¹æ¡ˆ**: v2.0 Final (2025-10-18)  

---

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
2. [æŠ€æœ¯æ¶æ„åˆ†æ](#2-æŠ€æœ¯æ¶æ„åˆ†æ)
3. [å¼€å‘é˜¶æ®µè§„åˆ’](#3-å¼€å‘é˜¶æ®µè§„åˆ’)
4. [æ ¸å¿ƒæ¨¡å—å¼€å‘é¡ºåº](#4-æ ¸å¿ƒæ¨¡å—å¼€å‘é¡ºåº)
5. [è¯¦ç»†å®ç°è®¡åˆ’](#5-è¯¦ç»†å®ç°è®¡åˆ’)
6. [æŠ€æœ¯æ ˆé€‰æ‹©](#6-æŠ€æœ¯æ ˆé€‰æ‹©)
7. [å›¢é˜Ÿç»„ç»‡ä¸åˆ†å·¥](#7-å›¢é˜Ÿç»„ç»‡ä¸åˆ†å·¥)
8. [è´¨é‡ä¿è¯è®¡åˆ’](#8-è´¨é‡ä¿è¯è®¡åˆ’)
9. [é£é™©æ§åˆ¶ä¸åº”æ€¥é¢„æ¡ˆ](#9-é£é™©æ§åˆ¶ä¸åº”æ€¥é¢„æ¡ˆ)
10. [é‡Œç¨‹ç¢‘ä¸äº¤ä»˜ç‰©](#10-é‡Œç¨‹ç¢‘ä¸äº¤ä»˜ç‰©)
11. [èµ„æºéœ€æ±‚](#11-èµ„æºéœ€æ±‚)
12. [åç»­ç»´æŠ¤è®¡åˆ’](#12-åç»­ç»´æŠ¤è®¡åˆ’)

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®ç›®æ ‡

åŸºäºæŠ€æœ¯æ–¹æ¡ˆæ–‡æ¡£ï¼ŒEquiflux Chainçš„æ ¸å¿ƒç›®æ ‡æ˜¯ï¼š

- **é«˜æ€§èƒ½**: å®ç°â‰ˆ1800 TPSï¼ˆåŸºå‡†ï¼‰ï¼Œ3ç§’å‡ºå—ï¼Œ8ç§’ç¡®è®¤
- **é«˜å®‰å…¨æ€§**: ä¸‰å±‚æ··åˆå…±è¯†æœºåˆ¶ï¼ˆPoS + VRF + è½»é‡çº§PoWï¼‰
- **å¼ºå»ä¸­å¿ƒåŒ–**: 50ä¸ªè¶…çº§èŠ‚ç‚¹ï¼ŒåŠ¨æ€è½®æ¢æœºåˆ¶
- **å®Œå…¨å¯éªŒè¯**: æ‰€æœ‰VRFå…¬å¼€é€æ˜ï¼Œå®æ—¶éªŒè¯
- **ä½èƒ½è€—**: ç›¸æ¯”PoWèŠ‚èƒ½99.9%+

### 1.2 æ ¸å¿ƒåˆ›æ–°ç‚¹

1. **å®Œå…¨é€æ˜çš„VRFæœºåˆ¶**ï¼ˆæ ¸å¿ƒåˆ›æ–°ï¼‰
   - æ‰€æœ‰è¶…çº§èŠ‚ç‚¹å¼ºåˆ¶å…¬å¼€VRF
   - åŒºå—åŒ…å«æ‰€æœ‰VRFè¯æ˜
   - å®æ—¶éªŒè¯ï¼Œæ— å†å²æŒ‘æˆ˜
   - æ¿€åŠ±å‰15åï¼Œé¼“åŠ±è¯šå®

2. **ä¸‰å±‚æ··åˆå…±è¯†æ¶æ„**
   - Layer 1: PoSæ²»ç†å±‚ï¼ˆç¤¾åŒºæ²»ç†ï¼‰
   - Layer 2: VRFé€‰æ‹©å±‚ï¼ˆå…¬å¹³éšæœºï¼‰
   - Layer 3: LPoWé˜²æŠ¤å±‚ï¼ˆåä½œæ¶ï¼‰

3. **å®æ—¶æœ€ç»ˆæ€§ç¡®è®¤æœºåˆ¶**
   - ç¡®è®¤å³ä¸å¯é€†
   - æ— éœ€å†å²æŒ‘æˆ˜
   - æ°¸ä¸å›æ»š

### 1.3 æŠ€æœ¯è§„æ ¼

| æŒ‡æ ‡ | ç›®æ ‡å€¼ |
|------|--------|
| è¶…çº§èŠ‚ç‚¹æ•° | 50ä¸ªï¼ˆ20æ ¸å¿ƒ+30è½®æ¢ï¼‰ |
| å‡ºå—æ—¶é—´ | 3ç§’ |
| ç¡®è®¤æ—¶é—´ | 8ç§’ï¼ˆ2-3ä¸ªåŒºå—åï¼‰ |
| ååé‡ | â‰ˆ1800 TPSï¼ˆåŸºå‡†ï¼‰ |
| èƒ½æºæ¶ˆè€— | 90 MWh/å¹´ |
| ç½‘ç»œæ¨¡å‹ | éƒ¨åˆ†åŒæ­¥ |
| æ‹œå åº­å®¹é”™ | f < n/3 |

---

## 2. æŠ€æœ¯æ¶æ„åˆ†æ

### 2.1 ä¸‰å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: PoSæ²»ç†å±‚ï¼ˆç¤¾åŒºæ²»ç†ï¼‰          â”‚
â”‚  - è´¨æŠ¼æŠ•ç¥¨é€‰ä¸¾è¶…çº§èŠ‚ç‚¹                   â”‚
â”‚  - æ—¶é—´åŠ æƒé¼“åŠ±é•¿æœŸæŒæœ‰                   â”‚
â”‚  - é˜²æ­¢å¯¡å¤´å„æ–­                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2: VRFé€‰æ‹©å±‚ï¼ˆå…¬å¹³éšæœºï¼‰          â”‚
â”‚  - å¯éªŒè¯éšæœºå‡½æ•°é€‰æ‹©å‡ºå—è€…               â”‚
â”‚  - æ‰€æœ‰VRFå…¬å¼€é€æ˜                       â”‚
â”‚  - å®æ—¶éªŒè¯åˆæ³•æ€§                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: LPoWé˜²æŠ¤å±‚ï¼ˆåä½œæ¶ï¼‰           â”‚
â”‚  - è½»é‡è®¡ç®—ï¼ˆ2-3ç§’CPUï¼‰                  â”‚
â”‚  - åŠ¨æ€æƒ©ç½šæœºåˆ¶                         â”‚
â”‚  - å¢åŠ ä½œæ¶æˆæœ¬                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒç»„ä»¶åˆ†æ

#### 2.2.1 å…±è¯†å¼•æ“
- **VRFè®¡ç®—æ¨¡å—**: ECVRF (RFC 9381)å®ç°
- **èŠ‚ç‚¹ç®¡ç†æ¨¡å—**: åŠ¨æ€è½®æ¢ã€æ—¶é—´è¡°å‡
- **åŒºå—éªŒè¯æ¨¡å—**: å¤šå±‚éªŒè¯æœºåˆ¶
- **æƒ©ç½šæœºåˆ¶æ¨¡å—**: åŠ¨æ€éš¾åº¦è°ƒæ•´

#### 2.2.2 ç½‘ç»œå±‚
- **P2Pç½‘ç»œ**: Gossipåè®®å®ç°
- **æ¶ˆæ¯ä¼ æ’­**: VRFå…¬å‘Šã€åŒºå—ã€ç­¾å
- **è¿æ¥ç®¡ç†**: èŠ‚ç‚¹å‘ç°ã€ç»´æŠ¤

#### 2.2.3 å­˜å‚¨å±‚
- **åŒºå—é“¾å­˜å‚¨**: RocksDB
- **çŠ¶æ€ç®¡ç†**: è´¦æˆ·çŠ¶æ€ã€åˆçº¦çŠ¶æ€
- **äº¤æ˜“æ± **: å†…å­˜äº¤æ˜“æ± ç®¡ç†

#### 2.2.4 åº”ç”¨å±‚
- **RPCæ¥å£**: JSON-RPC 2.0
- **é’±åŒ…æœåŠ¡**: å¯†é’¥ç®¡ç†ã€äº¤æ˜“ç­¾å
- **åŒºå—æµè§ˆå™¨**: æ•°æ®æŸ¥è¯¢ã€å±•ç¤º

---

## 3. å¼€å‘é˜¶æ®µè§„åˆ’

### 3.1 æ€»ä½“å¼€å‘é˜¶æ®µ

```
Phase 0: å‡†å¤‡æœŸ
â”œâ”€ æŠ€æœ¯é€‰å‹ç¡®è®¤
â”œâ”€ æ¶æ„è®¾è®¡å®Œå–„
â”œâ”€ å¼€å‘ç¯å¢ƒæ­å»º
â””â”€ åŸºç¡€ç»„ä»¶å‡†å¤‡

Phase 1: æ ¸å¿ƒå¼€å‘
â”œâ”€ å…±è¯†å¼•æ“å®ç°
â”œâ”€ ç½‘ç»œå±‚å¼€å‘
â”œâ”€ å­˜å‚¨å±‚å¼€å‘
â””â”€ åŸºç¡€æµ‹è¯•

Phase 2: æµ‹è¯•ç½‘
â”œâ”€ å†…éƒ¨æµ‹è¯•ç½‘
â”œâ”€ å…¬å¼€æµ‹è¯•ç½‘
â”œâ”€ å®‰å…¨å®¡è®¡
â””â”€ æ€§èƒ½ä¼˜åŒ–

Phase 3: ä¸»ç½‘å‡†å¤‡
â”œâ”€ ä¸»ç½‘ä»£ç å†»ç»“
â”œâ”€ èŠ‚ç‚¹æ‹›å‹Ÿ
â”œâ”€ ç”Ÿæ€å»ºè®¾
â””â”€ ä¸Šçº¿å‡†å¤‡

Phase 4: ä¸»ç½‘è¿è¥
â”œâ”€ ä¸»ç½‘ä¸Šçº¿
â”œâ”€ ç”Ÿæ€å‘å±•
â”œâ”€ æŒç»­ä¼˜åŒ–
â””â”€ ç¤¾åŒºå»ºè®¾
```

### 3.2 å…³é”®é‡Œç¨‹ç¢‘

| é‡Œç¨‹ç¢‘ | äº¤ä»˜ç‰© | æˆåŠŸæ ‡å‡† |
|--------|--------|----------|
| **MVPå®Œæˆ** | æ ¸å¿ƒå…±è¯†å®ç° | å•æœºæµ‹è¯•é€šè¿‡ |
| **å†…éƒ¨æµ‹è¯•ç½‘** | 10èŠ‚ç‚¹æµ‹è¯•ç½‘ | ç¨³å®šè¿è¡Œ1ä¸ªæœˆ |
| **å…¬å¼€æµ‹è¯•ç½‘** | 50èŠ‚ç‚¹æµ‹è¯•ç½‘ | TPS>1000ï¼Œæ— é‡å¤§bug |
| **å®‰å…¨å®¡è®¡** | å®¡è®¡æŠ¥å‘Š | æ— é«˜å±æ¼æ´ |
| **ä¸»ç½‘ä¸Šçº¿** | ç”Ÿäº§ç¯å¢ƒ | ç¨³å®šè¿è¡Œï¼Œç”Ÿæ€å¯åŠ¨ |

---

## 4. æ ¸å¿ƒæ¨¡å—å¼€å‘é¡ºåº

### 4.1 å¼€å‘ä¼˜å…ˆçº§çŸ©é˜µ

| ä¼˜å…ˆçº§ | æ¨¡å— | ä¾èµ–å…³ç³» | å…³é”®æ€§ |
|--------|------|----------|--------|
| **P0** | å¯†ç å­¦åŸºç¡€ | æ—  | æé«˜ |
| **P0** | VRFå®ç° | å¯†ç å­¦åŸºç¡€ | æé«˜ |
| **P0** | åŸºç¡€æ•°æ®ç»“æ„ | æ—  | æé«˜ |
| **P0** | å…±è¯†å¼•æ“æ ¸å¿ƒ | VRF+æ•°æ®ç»“æ„ | æé«˜ |
| **P1** | ç½‘ç»œå±‚ | å…±è¯†å¼•æ“ | é«˜ |
| **P1** | å­˜å‚¨å±‚ | åŸºç¡€æ•°æ®ç»“æ„ | é«˜ |
| **P1** | åŒºå—éªŒè¯ | å…±è¯†å¼•æ“+å­˜å‚¨ | é«˜ |
| **P2** | RPCæ¥å£ | å­˜å‚¨å±‚ | ä¸­ |
| **P2** | é’±åŒ…æœåŠ¡ | RPCæ¥å£ | ä¸­ |
| **P3** | åŒºå—æµè§ˆå™¨ | RPCæ¥å£ | ä½ |

### 4.2 è¯¦ç»†å¼€å‘é¡ºåº

#### é˜¶æ®µ1: åŸºç¡€ç»„ä»¶

**é¡¹ç›®åˆå§‹åŒ–**
```bash
# é¡¹ç›®ç»“æ„
equiflux-node/
â”œâ”€â”€ src/main/java/io/equiflux/node/
â”‚   â”œâ”€â”€ consensus/          # å…±è¯†æ¨¡å—
â”‚   â”œâ”€â”€ crypto/            # å¯†ç å­¦æ¨¡å—
â”‚   â”œâ”€â”€ network/           # ç½‘ç»œæ¨¡å—
â”‚   â”œâ”€â”€ storage/           # å­˜å‚¨æ¨¡å—
â”‚   â”œâ”€â”€ rpc/               # RPCæ¥å£
â”‚   â”œâ”€â”€ wallet/            # é’±åŒ…æœåŠ¡
â”‚   â””â”€â”€ explorer/          # åŒºå—æµè§ˆå™¨
â”œâ”€â”€ src/test/java/         # æµ‹è¯•ä»£ç 
â”œâ”€â”€ src/main/resources/    # é…ç½®æ–‡ä»¶
â”œâ”€â”€ docs/                 # æ–‡æ¡£
â””â”€â”€ pom.xml               # Mavené…ç½®
```

**å¯†ç å­¦åŸºç¡€**
- [ ] Java 21å†…ç½®å¯†ç å­¦APIé›†æˆ
- [ ] Ed25519ç­¾åå®ç°
- [ ] SHA-256/SHA-3å“ˆå¸Œå®ç°
- [ ] HMAC-SHA256å®ç°
- [ ] å¯†é’¥å¯¹ç”Ÿæˆå’Œç®¡ç†
- [ ] åŸºç¡€åŠ å¯†å·¥å…·

**VRFå®ç°**
- [ ] åŸºäºJava 21å†…ç½®APIçš„VRFå®ç°
- [ ] HMAC-SHA256ä½œä¸ºVRFå‡½æ•°
- [ ] EdDSAç­¾åä½œä¸ºVRFè¯æ˜
- [ ] VRFå¯†é’¥å¯¹ç®¡ç†
- [ ] VRFè¯æ˜ç”Ÿæˆå’ŒéªŒè¯
- [ ] VRFæµ‹è¯•ç”¨ä¾‹

**åŸºç¡€æ•°æ®ç»“æ„**
- [ ] Blockç»“æ„å®šä¹‰ï¼ˆåŒ…å«æ‰€æœ‰VRFå…¬å‘Šï¼‰
- [ ] Transactionç»“æ„å®šä¹‰
- [ ] VRFAnnouncementç»“æ„
- [ ] VRFOutput/VRFProofç»“æ„
- [ ] åºåˆ—åŒ–/ååºåˆ—åŒ–

**å…±è¯†å¼•æ“æ ¸å¿ƒ**
- [ ] VRFæ”¶é›†é€»è¾‘ï¼ˆ3ç§’è¶…æ—¶ï¼‰
- [ ] å‡ºå—è€…é€‰æ‹©ç®—æ³•
- [ ] åŒºå—æ„é€ é€»è¾‘ï¼ˆåŒ…å«æ‰€æœ‰VRFï¼‰
- [ ] åŸºç¡€éªŒè¯é€»è¾‘
- [ ] å‰15åå¥–åŠ±æœºåˆ¶

#### é˜¶æ®µ2: ç½‘ç»œä¸å­˜å‚¨

**å­˜å‚¨å±‚**
- [ ] RocksDBé›†æˆ
- [ ] åŒºå—å­˜å‚¨
- [ ] çŠ¶æ€å­˜å‚¨
- [ ] äº¤æ˜“æ± å®ç°

**ç½‘ç»œå±‚**
- [ ] P2Pç½‘ç»œå®ç°
- [ ] Gossipåè®®
- [ ] VRFå…¬å‘Šä¼ æ’­
- [ ] åŒºå—ä¼ æ’­
- [ ] è¿æ¥ç®¡ç†

**åŒºå—éªŒè¯**
- [ ] VRFå®Œæ•´æ€§éªŒè¯
- [ ] å‡ºå—è€…åˆæ³•æ€§éªŒè¯
- [ ] PoWéªŒè¯
- [ ] äº¤æ˜“éªŒè¯
- [ ] ç­¾åéªŒè¯

**é›†æˆæµ‹è¯•**
- [ ] å•å…ƒæµ‹è¯•å®Œå–„
- [ ] é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] å‹åŠ›æµ‹è¯•

#### é˜¶æ®µ3: åº”ç”¨å±‚

**RPCæ¥å£**
- [ ] JSON-RPC 2.0å®ç°
- [ ] åŸºç¡€APIæ¥å£
- [ ] é”™è¯¯å¤„ç†
- [ ] æ¥å£æ–‡æ¡£

**é’±åŒ…æœåŠ¡**
- [ ] å¯†é’¥ç®¡ç†
- [ ] äº¤æ˜“ç­¾å
- [ ] ä½™é¢æŸ¥è¯¢
- [ ] äº¤æ˜“å¹¿æ’­

**åŒºå—æµè§ˆå™¨**
- [ ] åŒºå—æŸ¥è¯¢
- [ ] äº¤æ˜“æŸ¥è¯¢
- [ ] è´¦æˆ·æŸ¥è¯¢
- [ ] Webç•Œé¢

**æµ‹è¯•ç½‘å‡†å¤‡**
- [ ] æµ‹è¯•ç½‘é…ç½®
- [ ] èŠ‚ç‚¹éƒ¨ç½²è„šæœ¬
- [ ] ç›‘æ§ç³»ç»Ÿ
- [ ] æ–‡æ¡£å®Œå–„

---

## 5. è¯¦ç»†å®ç°è®¡åˆ’

### 5.1 å…±è¯†å¼•æ“å®ç°

#### 5.1.1 VRFæ”¶é›†é˜¶æ®µï¼ˆ3ç§’è¶…æ—¶ï¼‰

```java
// src/main/java/io/equiflux/node/consensus/VRFCollector.java
package io.equiflux.node.consensus;

@Component
public class VRFCollector {
    private final VRFKeyPair vrfKeys;
    private final NetworkService networkService;
    private final Duration timeout;
    
    public VRFCollector(VRFKeyPair vrfKeys, NetworkService networkService) {
        this.vrfKeys = vrfKeys;
        this.networkService = networkService;
        this.timeout = Duration.ofSeconds(3);
    }
    
    public CompletableFuture<VRFRoundResult> collectVRFs(long round) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 1. è®¡ç®—VRFè¾“å…¥
                byte[] vrfInput = computeVRFInput(round);
                
                // 2. è®¡ç®—æˆ‘çš„VRF
                VRFAnnouncement myVRF = computeMyVRF(vrfInput);
                
                // 3. å¹¿æ’­VRFå…¬å‘Š
                broadcastVRFAnnouncement(myVRF).join();
                
                // 4. æ”¶é›†å…¶ä»–èŠ‚ç‚¹çš„VRFï¼ˆç­‰å¾…3ç§’ï¼‰
                List<VRFAnnouncement> collected = collectOtherVRFs(round, timeout).join();
                
                // 5. éªŒè¯æ‰€æœ‰VRF
                List<VRFAnnouncement> validVRFs = validateVRFs(collected, vrfInput);
                
                // 6. ç¡®å®šå‡ºå—è€…å’Œå‰15å
                VRFAnnouncement winner = selectWinner(validVRFs);
                List<VRFAnnouncement> top15 = selectTop15(validVRFs);
                
                return new VRFRoundResult(winner, top15, validVRFs);
            } catch (Exception e) {
                throw new ConsensusException("VRF collection failed", e);
            }
        });
    }
    
    private CompletableFuture<Void> broadcastVRFAnnouncement(VRFAnnouncement announcement) {
        return networkService.broadcastVRF(announcement);
    }
    
    private CompletableFuture<List<VRFAnnouncement>> collectOtherVRFs(long round, Duration timeout) {
        return CompletableFuture.supplyAsync(() -> {
            long startTime = System.currentTimeMillis();
            List<VRFAnnouncement> collected = new ArrayList<>();
            
            while (System.currentTimeMillis() - startTime < timeout.toMillis()) {
                List<VRFAnnouncement> newVRFs = networkService.getVRFAnnouncements(round);
                collected.addAll(newVRFs);
                
                try {
                    Thread.sleep(100); // é¿å…å¿™ç­‰å¾…
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            return collected;
        });
    }
}
```

#### 5.1.2 å‡ºå—ä¸éªŒè¯é˜¶æ®µï¼ˆ5ç§’è¶…æ—¶ï¼‰

```java
// src/main/java/io/equiflux/node/consensus/BlockProposer.java
package io.equiflux.node.consensus;

@Component
public class BlockProposer {
    private final ConsensusEngine consensusEngine;
    private final TransactionPool txPool;
    private final VRFKeyPair vrfKeys;
    
    public BlockProposer(ConsensusEngine consensusEngine, 
                        TransactionPool txPool, 
                        VRFKeyPair vrfKeys) {
        this.consensusEngine = consensusEngine;
        this.txPool = txPool;
        this.vrfKeys = vrfKeys;
    }
    
    public CompletableFuture<Block> proposeBlock(long round, VRFRoundResult vrfResult) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 1. æ„é€ åŒºå—å¤´
                Block block = new Block();
                block.setHeight(consensusEngine.getHeight() + 1);
                block.setRound(round);
                block.setTimestamp(System.currentTimeMillis());
                block.setPreviousHash(consensusEngine.getLastBlockHash());
                block.setProposer(vrfKeys.getPublicKey());
                block.setVrfOutput(vrfResult.getWinner().getOutput());
                block.setVrfProof(vrfResult.getWinner().getProof());
                block.setAllVrfAnnouncements(vrfResult.getAllValid());
                block.setRewardedNodes(vrfResult.getTop15().stream()
                    .map(VRFAnnouncement::getPublicKey)
                    .collect(Collectors.toList()));
                block.setTransactions(selectTransactions());
                block.setNonce(0);
                block.setDifficultyTarget(getDifficulty());
                block.setSignatures(new HashMap<>());
                
                // 2. è®¡ç®—Merkleæ ¹
                block.setMerkleRoot(MerkleTree.computeRoot(block.getTransactions()));
                
                // 3. æ‰§è¡ŒPoW
                minePoW(block).join();
                
                // 4. å¹¿æ’­åŒºå—
                broadcastBlock(block).join();
                
                return block;
            } catch (Exception e) {
                throw new ProposerException("Block proposal failed", e);
            }
        });
    }
    
    private CompletableFuture<Void> minePoW(Block block) {
        return CompletableFuture.runAsync(() -> {
            BigInteger target = block.getDifficultyTarget();
            long nonce = 0;
            
            while (true) {
                block.setNonce(nonce);
                byte[] blockHash = HashUtils.sha256(block.serialize());
                BigInteger hashValue = new BigInteger(1, blockHash);
                
                if (hashValue.compareTo(target) < 0) {
                    break;
                }
                
                nonce++;
                
                // æ£€æŸ¥æ˜¯å¦è¢«ä¸­æ–­
                if (Thread.currentThread().isInterrupted()) {
                    throw new RuntimeException("Mining interrupted");
                }
            }
        });
    }
    
    private CompletableFuture<Void> broadcastBlock(Block block) {
        return networkService.broadcastBlock(block);
    }
}
```

#### 5.1.3 åŒºå—éªŒè¯é€»è¾‘

```java
// src/main/java/io/equiflux/node/consensus/BlockValidator.java
package io.equiflux.node.consensus;

@Component
public class BlockValidator {
    
    public void verifyBlock(Block block) throws ValidationException {
        // Step 1: VRFå®Œæ•´æ€§éªŒè¯
        if (block.getAllVrfAnnouncements().size() < getMinVRFRequired()) {
            throw new ValidationException("Insufficient VRFs");
        }
        
        byte[] vrfInput = computeVRFInput(block.getPreviousHash(), block.getRound());
        
        for (VRFAnnouncement announcement : block.getAllVrfAnnouncements()) {
            // éªŒè¯VRFè¯æ˜
            if (!VRF.verify(announcement.getPublicKey(), vrfInput, 
                           announcement.getOutput(), announcement.getProof())) {
                throw new ValidationException("Invalid VRF for " + announcement.getPublicKey());
            }
            
            // éªŒè¯å¾—åˆ†è®¡ç®—
            double expectedScore = calculateScore(announcement.getPublicKey(), announcement.getOutput());
            if (Math.abs(expectedScore - announcement.getScore()) > EPSILON) {
                throw new ValidationException("Invalid score calculation");
            }
        }
        
        // Step 2: å‡ºå—è€…åˆæ³•æ€§éªŒè¯
        double proposerScore = getProposerScore(block);
        for (VRFAnnouncement announcement : block.getAllVrfAnnouncements()) {
            if (announcement.getScore() > proposerScore) {
                throw new ValidationException("Proposer not highest score");
            }
        }
        
        // Step 3: PoWéªŒè¯
        if (!verifyPoW(block)) {
            throw new ValidationException("Invalid PoW");
        }
        
        // Step 4: äº¤æ˜“éªŒè¯
        for (Transaction tx : block.getTransactions()) {
            validateTransaction(tx);
        }
    }
    
    private boolean verifyPoW(Block block) {
        byte[] blockHash = HashUtils.sha256(block.serialize());
        BigInteger hashValue = new BigInteger(1, blockHash);
        return hashValue.compareTo(block.getDifficultyTarget()) < 0;
    }
    
    private void validateTransaction(Transaction tx) throws ValidationException {
        // éªŒè¯äº¤æ˜“ç­¾å
        if (!tx.verifySignature()) {
            throw new ValidationException("Invalid transaction signature");
        }
        
        // éªŒè¯äº¤æ˜“æ ¼å¼
        if (!tx.isValidFormat()) {
            throw new ValidationException("Invalid transaction format");
        }
        
        // éªŒè¯ä½™é¢
        if (!hasSufficientBalance(tx)) {
            throw new ValidationException("Insufficient balance");
        }
    }
}
```

#### 5.1.4 VRFå®ç° - ä½¿ç”¨Java 21å†…ç½®å¯†ç å­¦API

```java
// src/main/java/io/equiflux/node/crypto/VRFCalculator.java
package io.equiflux.node.crypto;

@Component
public class VRFCalculator {
    private static final Logger logger = LoggerFactory.getLogger(VRFCalculator.class);
    
    // ä½¿ç”¨Java 21å†…ç½®çš„EdDSAç®—æ³•å®ç°VRF
    private static final String ALGORITHM = "Ed25519";
    private static final String PROVIDER = "SunEC";
    
    /**
     * ç”ŸæˆVRFå¯†é’¥å¯¹
     */
    public VRFKeyPair generateKeyPair() {
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(ALGORITHM, PROVIDER);
            keyGen.initialize(256); // Ed25519ä½¿ç”¨256ä½å¯†é’¥
            KeyPair keyPair = keyGen.generateKeyPair();
            
            return new VRFKeyPair(
                new VRFSecretKey(keyPair.getPrivate()),
                new VRFPublicKey(keyPair.getPublic())
            );
        } catch (Exception e) {
            throw new CryptoException("Failed to generate VRF key pair", e);
        }
    }
    
    /**
     * è®¡ç®—VRFè¾“å‡º
     */
    public VRFOutput evaluate(VRFSecretKey secretKey, byte[] input) {
        try {
            // ä½¿ç”¨HMAC-SHA256ä½œä¸ºVRFå‡½æ•°
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKeySpec = new SecretKeySpec(
                secretKey.getEncoded(), "HmacSHA256");
            mac.init(secretKeySpec);
            
            byte[] output = mac.doFinal(input);
            
            // ç”ŸæˆVRFè¯æ˜
            VRFProof proof = generateProof(secretKey, input, output);
            
            return new VRFOutput(output, proof);
        } catch (Exception e) {
            throw new CryptoException("VRF evaluation failed", e);
        }
    }
    
    /**
     * éªŒè¯VRFè¾“å‡º
     */
    public boolean verify(VRFPublicKey publicKey, byte[] input, 
                         VRFOutput output, VRFProof proof) {
        try {
            // é‡æ–°è®¡ç®—VRFè¾“å‡º
            VRFOutput expectedOutput = evaluateFromPublicKey(publicKey, input, proof);
            
            // æ¯”è¾ƒè¾“å‡º
            return Arrays.equals(output.getOutput(), expectedOutput.getOutput());
        } catch (Exception e) {
            logger.error("VRF verification failed", e);
            return false;
        }
    }
    
    /**
     * è®¡ç®—VRFå¾—åˆ†
     */
    public double calculateScore(VRFPublicKey publicKey, VRFOutput output, 
                               double stakeWeight, double performanceFactor) {
        // å°†VRFè¾“å‡ºè½¬æ¢ä¸º0-1ä¹‹é—´çš„åˆ†æ•°
        BigInteger outputInt = new BigInteger(1, output.getOutput());
        double vrfScore = outputInt.doubleValue() / Math.pow(2, 256);
        
        // åº”ç”¨æƒç›Šæƒé‡å’Œæ€§èƒ½å› å­
        return vrfScore * Math.sqrt(stakeWeight) * performanceFactor;
    }
    
    /**
     * ç”ŸæˆVRFè¯æ˜
     */
    private VRFProof generateProof(VRFSecretKey secretKey, byte[] input, byte[] output) {
        try {
            // ä½¿ç”¨EdDSAç­¾åä½œä¸ºVRFè¯æ˜
            Signature signature = Signature.getInstance(ALGORITHM, PROVIDER);
            signature.initSign(secretKey.getPrivateKey());
            
            // å°†è¾“å…¥å’Œè¾“å‡ºç»„åˆä½œä¸ºç­¾åæ•°æ®
            byte[] dataToSign = new byte[input.length + output.length];
            System.arraycopy(input, 0, dataToSign, 0, input.length);
            System.arraycopy(output, 0, dataToSign, input.length, output.length);
            
            signature.update(dataToSign);
            byte[] proofBytes = signature.sign();
            
            return new VRFProof(proofBytes);
        } catch (Exception e) {
            throw new CryptoException("Failed to generate VRF proof", e);
        }
    }
    
    /**
     * ä»å…¬é’¥éªŒè¯VRFè¯æ˜
     */
    private VRFOutput evaluateFromPublicKey(VRFPublicKey publicKey, byte[] input, VRFProof proof) {
        try {
            // ä½¿ç”¨HMAC-SHA256è®¡ç®—VRFè¾“å‡º
            Mac mac = Mac.getInstance("HmacSHA256");
            
            // ä»å…¬é’¥æ´¾ç”Ÿå¯†é’¥ææ–™
            byte[] keyMaterial = publicKey.getEncoded();
            SecretKeySpec secretKeySpec = new SecretKeySpec(keyMaterial, "HmacSHA256");
            mac.init(secretKeySpec);
            
            byte[] output = mac.doFinal(input);
            
            return new VRFOutput(output, proof);
        } catch (Exception e) {
            throw new CryptoException("Failed to evaluate VRF from public key", e);
        }
    }
}

/**
 * VRFå¯†é’¥å¯¹
 */
public class VRFKeyPair {
    private final VRFSecretKey secretKey;
    private final VRFPublicKey publicKey;
    
    public VRFKeyPair(VRFSecretKey secretKey, VRFPublicKey publicKey) {
        this.secretKey = secretKey;
        this.publicKey = publicKey;
    }
    
    public VRFSecretKey getSecretKey() { return secretKey; }
    public VRFPublicKey getPublicKey() { return publicKey; }
}

/**
 * VRFç§é’¥
 */
public class VRFSecretKey {
    private final PrivateKey privateKey;
    
    public VRFSecretKey(PrivateKey privateKey) {
        this.privateKey = privateKey;
    }
    
    public PrivateKey getPrivateKey() { return privateKey; }
    public byte[] getEncoded() { return privateKey.getEncoded(); }
}

/**
 * VRFå…¬é’¥
 */
public class VRFPublicKey {
    private final PublicKey publicKey;
    
    public VRFPublicKey(PublicKey publicKey) {
        this.publicKey = publicKey;
    }
    
    public PublicKey getPublicKey() { return publicKey; }
    public byte[] getEncoded() { return publicKey.getEncoded(); }
}

/**
 * VRFè¾“å‡º
 */
public class VRFOutput {
    private final byte[] output;
    private final VRFProof proof;
    
    public VRFOutput(byte[] output, VRFProof proof) {
        this.output = output;
        this.proof = proof;
    }
    
    public byte[] getOutput() { return output; }
    public VRFProof getProof() { return proof; }
}

/**
 * VRFè¯æ˜
 */
public class VRFProof {
    private final byte[] proof;
    
    public VRFProof(byte[] proof) {
        this.proof = proof;
    }
    
    public byte[] getProof() { return proof; }
}

/**
 * VRFå…¬å‘Š
 */
public class VRFAnnouncement {
    private final long round;
    private final VRFPublicKey publicKey;
    private final VRFOutput output;
    private final VRFProof proof;
    private final double score;
    private final long timestamp;
    
    public VRFAnnouncement(long round, VRFPublicKey publicKey, 
                           VRFOutput output, VRFProof proof, double score) {
        this.round = round;
        this.publicKey = publicKey;
        this.output = output;
        this.proof = proof;
        this.score = score;
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters
    public long getRound() { return round; }
    public VRFPublicKey getPublicKey() { return publicKey; }
    public VRFOutput getOutput() { return output; }
    public VRFProof getProof() { return proof; }
    public double getScore() { return score; }
    public long getTimestamp() { return timestamp; }
}

/**
 * å¯†ç å­¦å¼‚å¸¸
 */
public class CryptoException extends RuntimeException {
    public CryptoException(String message) {
        super(message);
    }
    
    public CryptoException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

#### 5.1.5 ç­¾åéªŒè¯ - ä½¿ç”¨Java 21å†…ç½®API

```java
// src/main/java/io/equiflux/node/crypto/SignatureVerifier.java
package io.equiflux.node.crypto;

@Component
public class SignatureVerifier {
    private static final Logger logger = LoggerFactory.getLogger(SignatureVerifier.class);
    
    /**
     * éªŒè¯åŒºå—ç­¾å
     */
    public boolean verifyBlockSignature(Block block, VRFPublicKey publicKey, byte[] signature) {
        try {
            Signature sig = Signature.getInstance("Ed25519", "SunEC");
            sig.initVerify(publicKey.getPublicKey());
            
            // æ„é€ ç­¾åæ•°æ®
            byte[] dataToVerify = block.serializeForSigning();
            sig.update(dataToVerify);
            
            return sig.verify(signature);
        } catch (Exception e) {
            logger.error("Block signature verification failed", e);
            return false;
        }
    }
    
    /**
     * éªŒè¯äº¤æ˜“ç­¾å
     */
    public boolean verifyTransactionSignature(Transaction transaction) {
        try {
            Signature sig = Signature.getInstance("Ed25519", "SunEC");
            sig.initVerify(transaction.getSenderPublicKey());
            
            byte[] dataToVerify = transaction.serializeForSigning();
            sig.update(dataToVerify);
            
            return sig.verify(transaction.getSignature());
        } catch (Exception e) {
            logger.error("Transaction signature verification failed", e);
            return false;
        }
    }
    
    /**
     * ç”Ÿæˆç­¾å
     */
    public byte[] sign(VRFSecretKey secretKey, byte[] data) {
        try {
            Signature sig = Signature.getInstance("Ed25519", "SunEC");
            sig.initSign(secretKey.getPrivateKey());
            sig.update(data);
            
            return sig.sign();
        } catch (Exception e) {
            throw new CryptoException("Signing failed", e);
        }
    }
}
```

### 5.2 ç½‘ç»œå±‚å®ç°

#### 5.2.1 P2Pç½‘ç»œæ¶æ„

```java
// src/main/java/io/equiflux/node/network/P2PNetwork.java
package io.equiflux.node.network;

@Component
public class P2PNetwork {
    private final PeerManager peerManager;
    private final MessageHandler messageHandler;
    private final EventLoopGroup bossGroup;
    private final EventLoopGroup workerGroup;
    private final ServerBootstrap bootstrap;
    
    public P2PNetwork(PeerManager peerManager, MessageHandler messageHandler) {
        this.peerManager = peerManager;
        this.messageHandler = messageHandler;
        this.bossGroup = new NioEventLoopGroup();
        this.workerGroup = new NioEventLoopGroup();
        this.bootstrap = new ServerBootstrap();
    }
    
    public CompletableFuture<Void> start() {
        return CompletableFuture.runAsync(() -> {
            try {
                bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        public void initChannel(SocketChannel ch) {
                            ChannelPipeline pipeline = ch.pipeline();
                            pipeline.addLast(new MessageDecoder());
                            pipeline.addLast(new MessageEncoder());
                            pipeline.addLast(new NetworkMessageHandler(messageHandler));
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
                
                ChannelFuture future = bootstrap.bind(30333).sync();
                future.channel().closeFuture().sync();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new NetworkException("Network startup interrupted", e);
            } finally {
                shutdown();
            }
        });
    }
    
    public CompletableFuture<Void> broadcastVRF(VRFAnnouncement announcement) {
        return CompletableFuture.runAsync(() -> {
            List<Peer> peers = peerManager.getActivePeers();
            for (Peer peer : peers) {
                peer.sendMessage(announcement);
            }
        });
    }
    
    public CompletableFuture<Void> broadcastBlock(Block block) {
        return CompletableFuture.runAsync(() -> {
            List<Peer> peers = peerManager.getActivePeers();
            for (Peer peer : peers) {
                peer.sendMessage(block);
            }
        });
    }
    
    private void shutdown() {
        workerGroup.shutdownGracefully();
        bossGroup.shutdownGracefully();
    }
}
```

#### 5.2.2 Gossipåè®®å®ç°

```java
// src/main/java/io/equiflux/node/network/GossipProtocol.java
package io.equiflux.node.network;

@Component
public class GossipProtocol {
    private final Map<String, Topic> topics;
    private final ConcurrentHashMap<String, List<byte[]>> messageCache;
    private final ScheduledExecutorService scheduler;
    
    public GossipProtocol() {
        this.topics = new ConcurrentHashMap<>();
        this.messageCache = new ConcurrentHashMap<>();
        this.scheduler = Executors.newScheduledThreadPool(4);
    }
    
    public CompletableFuture<Void> broadcastVRF(VRFAnnouncement announcement) {
        return CompletableFuture.runAsync(() -> {
            Topic topic = topics.get("vrf-announcements");
            if (topic != null) {
                byte[] message = announcement.serialize();
                
                // å‘å¸ƒåˆ°gossipç½‘ç»œ
                topic.publish(message);
                
                // ç¼“å­˜æ¶ˆæ¯
                String key = "vrf_" + announcement.getRound();
                messageCache.computeIfAbsent(key, k -> new ArrayList<>()).add(message);
            }
        });
    }
    
    public CompletableFuture<List<VRFAnnouncement>> collectVRFs(long round, Duration timeout) {
        return CompletableFuture.supplyAsync(() -> {
            long deadline = System.currentTimeMillis() + timeout.toMillis();
            List<VRFAnnouncement> collected = new ArrayList<>();
            
            while (System.currentTimeMillis() < deadline) {
                // ä»ç¼“å­˜ä¸­è·å–VRFå…¬å‘Š
                String key = "vrf_" + round;
                List<byte[]> messages = messageCache.get(key);
                
                if (messages != null) {
                    for (byte[] data : messages) {
                        try {
                            VRFAnnouncement announcement = VRFAnnouncement.deserialize(data);
                            collected.add(announcement);
                        } catch (Exception e) {
                            log.warn("Failed to deserialize VRF announcement", e);
                        }
                    }
                }
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            return collected;
        });
    }
    
    public void registerTopic(String name, Topic topic) {
        topics.put(name, topic);
    }
    
    @PreDestroy
    public void shutdown() {
        scheduler.shutdown();
    }
}
```

### 5.3 å­˜å‚¨å±‚å®ç°

#### 5.3.1 RocksDBé›†æˆ

```java
// src/main/java/io/equiflux/node/storage/RocksDBStorage.java
package io.equiflux.node.storage;

@Component
public class RocksDBStorage {
    private final RocksDB db;
    private final ConcurrentHashMap<Long, Block> blockCache;
    private final ConcurrentHashMap<String, AccountState> stateCache;
    
    public RocksDBStorage(@Value("${equiflux.storage.path:/data/equiflux}") String path) {
        try {
            // é…ç½®RocksDBé€‰é¡¹
            Options options = new Options();
            options.setCreateIfMissing(true);
            options.setMaxOpenFiles(1000);
            options.setWriteBufferSize(64 * 1024 * 1024); // 64MB
            
            this.db = RocksDB.open(options, path);
            this.blockCache = new ConcurrentHashMap<>();
            this.stateCache = new ConcurrentHashMap<>();
        } catch (RocksDBException e) {
            throw new StorageException("Failed to initialize RocksDB", e);
        }
    }
    
    public CompletableFuture<Void> storeBlock(Block block) {
        return CompletableFuture.runAsync(() -> {
            try {
                String key = "block_" + block.getHeight();
                byte[] value = block.serialize();
                
                db.put(key.getBytes(), value);
                
                // æ›´æ–°ç¼“å­˜
                blockCache.put(block.getHeight(), block);
            } catch (RocksDBException e) {
                throw new StorageException("Failed to store block", e);
            }
        });
    }
    
    public CompletableFuture<Optional<Block>> getBlock(long height) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // å…ˆæŸ¥ç¼“å­˜
                Block cachedBlock = blockCache.get(height);
                if (cachedBlock != null) {
                    return Optional.of(cachedBlock);
                }
                
                // æŸ¥æ•°æ®åº“
                String key = "block_" + height;
                byte[] data = db.get(key.getBytes());
                
                if (data != null) {
                    Block block = Block.deserialize(data);
                    
                    // æ›´æ–°ç¼“å­˜
                    blockCache.put(height, block);
                    
                    return Optional.of(block);
                } else {
                    return Optional.empty();
                }
            } catch (RocksDBException e) {
                throw new StorageException("Failed to get block", e);
            }
        });
    }
    
    public CompletableFuture<Void> storeAccountState(String address, AccountState state) {
        return CompletableFuture.runAsync(() -> {
            try {
                String key = "account_" + address;
                byte[] value = state.serialize();
                
                db.put(key.getBytes(), value);
                
                // æ›´æ–°ç¼“å­˜
                stateCache.put(address, state);
            } catch (RocksDBException e) {
                throw new StorageException("Failed to store account state", e);
            }
        });
    }
    
    @PreDestroy
    public void close() {
        if (db != null) {
            db.close();
        }
    }
}
```

#### 5.3.2 äº¤æ˜“æ± å®ç°

```java
// src/main/java/io/equiflux/node/storage/TransactionPool.java
package io.equiflux.node.storage;

@Component
public class TransactionPool {
    private final ConcurrentHashMap<String, Transaction> pendingTxs;
    private final int maxSize;
    private final long feeThreshold;
    private final ReentrantReadWriteLock lock;
    
    public TransactionPool(@Value("${equiflux.txpool.max-size:10000}") int maxSize,
                          @Value("${equiflux.txpool.fee-threshold:1000}") long feeThreshold) {
        this.pendingTxs = new ConcurrentHashMap<>();
        this.maxSize = maxSize;
        this.feeThreshold = feeThreshold;
        this.lock = new ReentrantReadWriteLock();
    }
    
    public CompletableFuture<Void> addTransaction(Transaction tx) {
        return CompletableFuture.runAsync(() -> {
            try {
                // éªŒè¯äº¤æ˜“
                validateTransaction(tx);
                
                // æ£€æŸ¥æ‰‹ç»­è´¹
                if (tx.getFee() < feeThreshold) {
                    throw new TxPoolException("Insufficient fee");
                }
                
                lock.writeLock().lock();
                try {
                    // å¦‚æœæ± æ»¡äº†ï¼Œç§»é™¤æ‰‹ç»­è´¹æœ€ä½çš„äº¤æ˜“
                    if (pendingTxs.size() >= maxSize) {
                        evictLowestFeeTx();
                    }
                    
                    pendingTxs.put(tx.getHash(), tx);
                } finally {
                    lock.writeLock().unlock();
                }
            } catch (Exception e) {
                throw new TxPoolException("Failed to add transaction", e);
            }
        });
    }
    
    public CompletableFuture<List<Transaction>> selectTransactions(int maxCount) {
        return CompletableFuture.supplyAsync(() -> {
            lock.readLock().lock();
            try {
                // æŒ‰æ‰‹ç»­è´¹æ’åº
                List<Transaction> txs = new ArrayList<>(pendingTxs.values());
                txs.sort((a, b) -> Long.compare(b.getFee(), a.getFee()));
                
                return txs.stream()
                    .limit(maxCount)
                    .collect(Collectors.toList());
            } finally {
                lock.readLock().unlock();
            }
        });
    }
    
    private void evictLowestFeeTx() {
        Transaction lowestFeeTx = pendingTxs.values().stream()
            .min(Comparator.comparing(Transaction::getFee))
            .orElse(null);
            
        if (lowestFeeTx != null) {
            pendingTxs.remove(lowestFeeTx.getHash());
        }
    }
    
    private void validateTransaction(Transaction tx) throws ValidationException {
        // éªŒè¯äº¤æ˜“ç­¾å
        if (!tx.verifySignature()) {
            throw new ValidationException("Invalid transaction signature");
        }
        
        // éªŒè¯äº¤æ˜“æ ¼å¼
        if (!tx.isValidFormat()) {
            throw new ValidationException("Invalid transaction format");
        }
        
        // æ£€æŸ¥é‡å¤äº¤æ˜“
        if (pendingTxs.containsKey(tx.getHash())) {
            throw new ValidationException("Duplicate transaction");
        }
    }
}
```

---

## 6. æŠ€æœ¯æ ˆé€‰æ‹©

### 6.1 ç¼–ç¨‹è¯­è¨€é€‰æ‹©

**é€‰æ‹©: Java 21 LTS**

**ç†ç”±:**
- ä¼ä¸šçº§ç¨³å®šæ€§ï¼Œæˆç†Ÿçš„æŠ€æœ¯ç”Ÿæ€
- Java 21å†…ç½®å¯†ç å­¦APIæ”¯æŒï¼ˆEdDSAã€ECDSAã€SHA-256ã€SHA-3ã€HMACç­‰ï¼‰
- æ— éœ€é¢å¤–å¯†ç å­¦åº“ï¼Œå‡å°‘å®‰å…¨é£é™©å’Œä¾èµ–å¤æ‚åº¦
- ä¼˜ç§€çš„è·¨å¹³å°æ”¯æŒï¼ŒJVMçš„å¼ºå¤§æ€§èƒ½
- å¼ºå¤§çš„å¹¶å‘æ”¯æŒï¼ˆCompletableFutureã€Reactive Streamsï¼‰
- å¼ºç±»å‹ç³»ç»Ÿï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯
- åºå¤§çš„å¼€å‘è€…ç¤¾åŒºå’Œäººæ‰å‚¨å¤‡
- ä¼˜ç§€çš„å·¥å…·é“¾æ”¯æŒï¼ˆIDEã€è°ƒè¯•ã€æ€§èƒ½åˆ†æï¼‰

### 6.2 æ ¸å¿ƒä¾èµ–åº“

```xml
<!-- pom.xml -->
<dependencies>
    <!-- å¯†ç å­¦ - ä½¿ç”¨Java 21å†…ç½®æ”¯æŒ -->
    <!-- Java 21å†…ç½®å¯†ç å­¦APIï¼Œæ— éœ€é¢å¤–ä¾èµ– -->
    <!-- æ”¯æŒçš„ç®—æ³•ï¼šEdDSA, ECDSA, SHA-256, SHA-3, HMAC, PBKDF2ç­‰ -->
    <!-- 
    ä¼˜åŠ¿ï¼š
    1. æ— éœ€å¤–éƒ¨ä¾èµ–ï¼Œå‡å°‘å®‰å…¨é£é™©
    2. æ€§èƒ½ä¼˜åŒ–ï¼Œç”±JVMåŸç”Ÿæ”¯æŒ
    3. æ›´å¥½çš„å†…å­˜ç®¡ç†å’Œåƒåœ¾å›æ”¶
    4. ä¸Javaç”Ÿæ€ç³»ç»Ÿå®Œç¾é›†æˆ
    5. é•¿æœŸç»´æŠ¤å’Œæ›´æ–°ä¿éšœ
    -->
    
    <!-- ç½‘ç»œ -->
    <dependency>
        <groupId>io.netty</groupId>
        <artifactId>netty-all</artifactId>
        <version>4.1.100.Final</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
        <version>3.2.0</version>
    </dependency>
    
    <!-- å­˜å‚¨ -->
    <dependency>
        <groupId>org.rocksdb</groupId>
        <artifactId>rocksdbjni</artifactId>
        <version>8.7.3</version>
    </dependency>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.2</version>
    </dependency>
    
    <!-- å·¥å…· -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
        <version>3.2.0</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.9</version>
    </dependency>
    
    <!-- æµ‹è¯• -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <version>3.2.0</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.10.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 6.3 å¼€å‘å·¥å…·é“¾

```bash
# å¿…éœ€å·¥å…·
# Javaå¼€å‘ç¯å¢ƒ
java -version  # éœ€è¦Java 21+
mvn -version   # Maven 3.8+

# IDEæ¨è
# IntelliJ IDEA Ultimate (æ¨è)
# Eclipse IDE for Java Developers
# Visual Studio Code with Java Extension Pack

# ä»£ç è´¨é‡å·¥å…·
mvn spotbugs:check      # é™æ€ä»£ç åˆ†æ
mvn pmd:check           # ä»£ç è§„èŒƒæ£€æŸ¥
mvn checkstyle:check    # ä»£ç é£æ ¼æ£€æŸ¥
mvn jacoco:report       # ä»£ç è¦†ç›–ç‡æŠ¥å‘Š

# æ€§èƒ½åˆ†æå·¥å…·
# JProfiler, VisualVM, JConsole
```

### 6.4 æµ‹è¯•æ¡†æ¶

```java
// å•å…ƒæµ‹è¯•
package io.equiflux.node.crypto;

@Test
public class VRFCalculatorTest {
    
    @Test
    public void testVRFCalculation() {
        VRFKeyPair keyPair = VRFKeyPair.generate();
        byte[] input = "test_input".getBytes();
        VRFOutput output = keyPair.evaluate(input);
        VRFProof proof = keyPair.prove(input);
        
        assertTrue(VRF.verify(keyPair.getPublicKey(), input, output, proof));
    }
    
    @Test
    public void testScoreCalculation() {
        VRFOutput vrfOutput = new VRFOutput(new byte[32]);
        double stakeWeight = 0.5;
        double performanceFactor = 1.0;
        
        double score = calculateScore(vrfOutput, stakeWeight, performanceFactor);
        assertTrue(score >= 0.0 && score <= 1.0);
    }
}

// é›†æˆæµ‹è¯•
package io.equiflux.node.consensus;

@SpringBootTest
@TestPropertySource(properties = "spring.profiles.active=test")
public class ConsensusIntegrationTest {
    
    @Autowired
    private ConsensusEngine consensusEngine;
    
    @Test
    public void testConsensusRound() throws Exception {
        // åˆ›å»ºæµ‹è¯•ç½‘ç»œ
        TestNetwork network = new TestNetwork(5);
        
        // è¿è¡Œä¸€è½®å…±è¯†
        CompletableFuture<Block> result = consensusEngine.runRound(1);
        
        // éªŒè¯ç»“æœ
        Block block = result.get(10, TimeUnit.SECONDS);
        assertEquals(1, block.getHeight());
        assertEquals(0, block.getTransactions().size());
    }
}

// æ€§èƒ½æµ‹è¯•
package io.equiflux.node.consensus;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@State(Scope.Benchmark)
public class ConsensusBenchmark {
    
    private ConsensusEngine consensusEngine;
    
    @Setup
    public void setup() {
        consensusEngine = new ConsensusEngine();
    }
    
    @Benchmark
    public void benchmarkVRFCollection() {
        // VRFæ”¶é›†æ€§èƒ½æµ‹è¯•
        consensusEngine.collectVRFs(1);
    }
    
    @Benchmark
    public void benchmarkBlockValidation() {
        // åŒºå—éªŒè¯æ€§èƒ½æµ‹è¯•
        Block block = createTestBlock();
        consensusEngine.validateBlock(block);
    }
}
```

---

## 7. å¼€å‘ç»„ç»‡ä¸åä½œ

### 7.1 å¼€å‘æ¨¡å¼

**å•äººå¼€å‘æ¨¡å¼**
- å…¨æ ˆå¼€å‘ï¼Œè´Ÿè´£æ‰€æœ‰æ¨¡å—
- é‡ç‚¹å…³æ³¨æ ¸å¿ƒå…±è¯†å¼•æ“
- æŒ‰ä¼˜å…ˆçº§é€æ­¥å®ç°å„æ¨¡å—

### 7.2 å¼€å‘é‡ç‚¹

#### æ ¸å¿ƒä¼˜å…ˆçº§
1. **å…±è¯†å¼•æ“** - å®Œå…¨é€æ˜VRFæœºåˆ¶å®ç°
2. **å¯†ç å­¦æ¨¡å—** - Java 21å†…ç½®APIé›†æˆ
3. **ç½‘ç»œå±‚** - P2Pé€šä¿¡å’ŒGossipåè®®
4. **å­˜å‚¨å±‚** - RocksDBé›†æˆ
5. **åº”ç”¨å±‚** - RPCæ¥å£å’ŒåŸºç¡€å·¥å…·

### 7.3 åä½œæµç¨‹

#### ä»£ç ç®¡ç†
```bash
# Gitå·¥ä½œæµ
main branch (ä¸»åˆ†æ”¯)
â”œâ”€â”€ feature/vrf-implementation
â”œâ”€â”€ feature/network-layer
â”œâ”€â”€ feature/storage-layer
â””â”€â”€ feature/rpc-interface
```

#### ä»£ç è´¨é‡
- ä¸¥æ ¼çš„ä»£ç å®¡æŸ¥ï¼ˆè‡ªæ£€ï¼‰
- å®Œå–„çš„å•å…ƒæµ‹è¯•
- ä»£ç è§„èŒƒæ£€æŸ¥
- æ€§èƒ½åŸºå‡†æµ‹è¯•

#### æ–‡æ¡£ç®¡ç†
- æŠ€æœ¯æ–‡æ¡£ä½¿ç”¨Markdownæ ¼å¼
- APIæ–‡æ¡£ä½¿ç”¨OpenAPIè§„èŒƒ
- ä»£ç æ³¨é‡Šä½¿ç”¨JavaDocæ ¼å¼

---

## 8. è´¨é‡ä¿è¯è®¡åˆ’

### 8.1 æµ‹è¯•ç­–ç•¥

#### 8.1.1 æµ‹è¯•é‡‘å­—å¡”

```
        E2Eæµ‹è¯• (5%)
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ å®Œæ•´ç³»ç»Ÿæµ‹è¯•  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ é›†æˆæµ‹è¯• (25%) â”‚ â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
  â”‚ å•å…ƒæµ‹è¯• (70%) â”‚ â”‚ â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
                  â”‚ â”‚
                  â””â”€â”˜
```

#### 8.1.2 æµ‹è¯•ç±»å‹

**å•å…ƒæµ‹è¯•**
```java
package io.equiflux.node.crypto;

@Test
public class VRFCalculatorTest {
    
    @Test
    public void testVRFCalculation() {
        VRFKeyPair keyPair = VRFKeyPair.generate();
        byte[] input = "test_input".getBytes();
        VRFOutput output = keyPair.evaluate(input);
        VRFProof proof = keyPair.prove(input);
        
        assertTrue(VRF.verify(keyPair.getPublicKey(), input, output, proof));
    }
    
    @Test
    public void testScoreCalculation() {
        VRFOutput vrfOutput = new VRFOutput(new byte[32]);
        double stakeWeight = 0.5;
        double performanceFactor = 1.0;
        
        double score = calculateScore(vrfOutput, stakeWeight, performanceFactor);
        assertTrue(score >= 0.0 && score <= 1.0);
    }
}
```

**é›†æˆæµ‹è¯•**
```java
package io.equiflux.node.consensus;

@SpringBootTest
@TestPropertySource(properties = "spring.profiles.active=test")
public class ConsensusIntegrationTest {
    
    @Autowired
    private ConsensusEngine consensusEngine;
    
    @Test
    public void testConsensusRound() throws Exception {
        // åˆ›å»ºæµ‹è¯•ç½‘ç»œ
        TestNetwork network = new TestNetwork(5);
        
        // è¿è¡Œä¸€è½®å…±è¯†
        CompletableFuture<Block> result = consensusEngine.runRound(1);
        
        // éªŒè¯ç»“æœ
        Block block = result.get(10, TimeUnit.SECONDS);
        assertEquals(1, block.getHeight());
        assertEquals(0, block.getTransactions().size());
    }
}
```

**æ€§èƒ½æµ‹è¯•**
```java
package io.equiflux.node.consensus;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@State(Scope.Benchmark)
public class ConsensusBenchmark {
    
    private ConsensusEngine consensusEngine;
    
    @Setup
    public void setup() {
        consensusEngine = new ConsensusEngine();
    }
    
    @Benchmark
    public void benchmarkVRFCollection() {
        // VRFæ”¶é›†æ€§èƒ½æµ‹è¯•
        consensusEngine.collectVRFs(1);
    }
    
    @Benchmark
    public void benchmarkBlockValidation() {
        // åŒºå—éªŒè¯æ€§èƒ½æµ‹è¯•
        Block block = createTestBlock();
        consensusEngine.validateBlock(block);
    }
}
```

#### 8.1.3 æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

| æ¨¡å—ç±»å‹ | è¦†ç›–ç‡è¦æ±‚ | å·¥å…· |
|----------|------------|------|
| æ ¸å¿ƒå…±è¯†æ¨¡å— | >95% | JaCoCo |
| ç½‘ç»œå±‚ | >90% | JaCoCo |
| å­˜å‚¨å±‚ | >90% | JaCoCo |
| åº”ç”¨å±‚ | >85% | JaCoCo |
| æ•´ä½“é¡¹ç›® | >90% | JaCoCo |

### 8.2 ä»£ç è´¨é‡

#### 8.2.1 ä»£ç è§„èŒƒ

```bash
# ä½¿ç”¨Mavenæ ¼å¼åŒ–ä»£ç 
mvn spotless:apply

# ä½¿ç”¨SpotBugsæ£€æŸ¥ä»£ç è´¨é‡
mvn spotbugs:check

# ä½¿ç”¨PMDæ£€æŸ¥ä»£ç è§„èŒƒ
mvn pmd:check

# ä½¿ç”¨Checkstyleæ£€æŸ¥ä»£ç é£æ ¼
mvn checkstyle:check
```

#### 8.2.2 é™æ€åˆ†æ

```xml
<!-- pom.xml -->
<build>
    <plugins>
        <plugin>
            <groupId>com.github.spotbugs</groupId>
            <artifactId>spotbugs-maven-plugin</artifactId>
            <version>4.7.3.0</version>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-pmd-plugin</artifactId>
            <version>3.21.0</version>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-checkstyle-plugin</artifactId>
            <version>3.3.0</version>
        </plugin>
        <plugin>
            <groupId>com.diffplug.spotless</groupId>
            <artifactId>spotless-maven-plugin</artifactId>
            <version>2.40.0</version>
        </plugin>
    </plugins>
</build>
```

#### 8.2.3 æŒç»­é›†æˆ

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        
    - name: Run tests
      run: mvn test
      
    - name: Run SpotBugs
      run: mvn spotbugs:check
      
    - name: Run PMD
      run: mvn pmd:check
      
    - name: Check formatting
      run: mvn spotless:check
      
    - name: Generate coverage report
      run: mvn jacoco:report
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
```

### 8.3 å®‰å…¨å®¡è®¡

#### 8.3.1 å®¡è®¡è®¡åˆ’

| é˜¶æ®µ | å®¡è®¡èŒƒå›´ | å®¡è®¡æœºæ„ | æ—¶é—´ |
|------|----------|----------|------|
| æµ‹è¯•ç½‘å‰ | æ ¸å¿ƒå…±è¯†æ¨¡å— | Trail of Bits | 2ä¸ªæœˆ |
| ä¸»ç½‘å‰ | å®Œæ•´ç³»ç»Ÿ | CertiK | 3ä¸ªæœˆ |
| ä¸»ç½‘å | æ™ºèƒ½åˆçº¦ | OpenZeppelin | 1ä¸ªæœˆ |

#### 8.3.2 å®‰å…¨æµ‹è¯•

```java
// æ¨¡ç³Šæµ‹è¯•
package io.equiflux.node.crypto;

@Property
public class VRFPropertyTest {
    
    @Property
    public void testVRFProperties(@ForAll byte[] input, @ForAll VRFKeyPair keyPair) {
        VRFOutput output = keyPair.evaluate(input);
        VRFProof proof = keyPair.prove(input);
        
        // VRFå±æ€§æµ‹è¯•
        assertTrue(VRF.verify(keyPair.getPublicKey(), input, output, proof));
    }
}
```

---

## 9. é£é™©æ§åˆ¶ä¸åº”æ€¥é¢„æ¡ˆ

### 9.1 æŠ€æœ¯é£é™©

#### 9.1.1 æ€§èƒ½ä¸è¾¾æ ‡é£é™©

**é£é™©æè¿°**: å®é™…TPS < 1000ï¼Œå‡ºå—æ—¶é—´ > 5ç§’

**é¢„é˜²æªæ–½**:
- æ—©æœŸæ€§èƒ½åŸºå‡†æµ‹è¯•
- æŒç»­æ€§èƒ½ç›‘æ§
- ä»£ç ä¼˜åŒ–å’Œå¹¶è¡ŒåŒ–

**åº”æ€¥é¢„æ¡ˆ**:
```java
// æ€§èƒ½ç›‘æ§
package io.equiflux.node.monitor;

@Component
public class PerformanceMonitor {
    private final ConcurrentHashMap<String, List<Duration>> metrics;
    private final MeterRegistry meterRegistry;
    
    public PerformanceMonitor(MeterRegistry meterRegistry) {
        this.metrics = new ConcurrentHashMap<>();
        this.meterRegistry = meterRegistry;
    }
    
    public void recordBlockTime(Duration duration) {
        List<Duration> blockTimes = metrics.computeIfAbsent("block_times", 
            k -> Collections.synchronizedList(new ArrayList<>()));
        blockTimes.add(duration);
        
        // å¦‚æœå¹³å‡å‡ºå—æ—¶é—´è¶…è¿‡5ç§’ï¼Œè§¦å‘å‘Šè­¦
        if (getAverageBlockTime().compareTo(Duration.ofSeconds(5)) > 0) {
            triggerPerformanceAlert();
        }
        
        // è®°å½•åˆ°Micrometer
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("block.time").register(meterRegistry));
    }
    
    private Duration getAverageBlockTime() {
        List<Duration> blockTimes = metrics.get("block_times");
        if (blockTimes == null || blockTimes.isEmpty()) {
            return Duration.ZERO;
        }
        
        return blockTimes.stream()
            .reduce(Duration.ZERO, Duration::plus)
            .dividedBy(blockTimes.size());
    }
    
    private void triggerPerformanceAlert() {
        // å‘é€æ€§èƒ½å‘Šè­¦
        log.warn("Performance alert: Average block time exceeds 5 seconds");
    }
}
```

#### 9.1.2 å®‰å…¨æ¼æ´é£é™©

**é£é™©æè¿°**: å‘ç°å…±è¯†å±‚æˆ–VRFå®ç°æ¼æ´

**é¢„é˜²æªæ–½**:
- å¤šè½®å®‰å…¨å®¡è®¡
- å½¢å¼åŒ–éªŒè¯
- æ¨¡ç³Šæµ‹è¯•

**åº”æ€¥é¢„æ¡ˆ**:
```java
// ç´§æ€¥æš‚åœæœºåˆ¶
package io.equiflux.node.safety;

@Component
public class EmergencyStop {
    private final AtomicBoolean isActive;
    private final ConsensusEngine consensusEngine;
    
    public EmergencyStop(ConsensusEngine consensusEngine) {
        this.isActive = new AtomicBoolean(false);
        this.consensusEngine = consensusEngine;
    }
    
    public void activate() {
        isActive.set(true);
        // åœæ­¢æ‰€æœ‰å…±è¯†æ´»åŠ¨
        stopConsensus();
    }
    
    public boolean isActive() {
        return isActive.get();
    }
    
    private void stopConsensus() {
        consensusEngine.stop();
        log.warn("Emergency stop activated - consensus halted");
    }
}
```

### 9.2 é¡¹ç›®é£é™©

#### 9.2.1 å¼€å‘å»¶æœŸé£é™©

**é£é™©æè¿°**: å…³é”®é‡Œç¨‹ç¢‘å»¶æœŸè¶…è¿‡1ä¸ªæœˆ

**é¢„é˜²æªæ–½**:
- ä¿å®ˆçš„æ—¶é—´ä¼°ç®—
- å¹¶è¡Œå¼€å‘
- å®šæœŸè¿›åº¦æ£€æŸ¥

**åº”æ€¥é¢„æ¡ˆ**:
- è°ƒæ•´åŠŸèƒ½ä¼˜å…ˆçº§
- å¢åŠ å¼€å‘äººå‘˜
- å¯»æ±‚å¤–éƒ¨æŠ€æœ¯æ”¯æŒ

#### 9.2.2 å›¢é˜Ÿæµå¤±é£é™©

**é£é™©æè¿°**: æ ¸å¿ƒå¼€å‘äººå‘˜ç¦»èŒ

**é¢„é˜²æªæ–½**:
- çŸ¥è¯†æ–‡æ¡£åŒ–
- ä»£ç å®¡æŸ¥åˆ¶åº¦
- å›¢é˜Ÿæ¿€åŠ±è®¡åˆ’

**åº”æ€¥é¢„æ¡ˆ**:
- å¿«é€Ÿæ‹›è˜æ›¿ä»£äººå‘˜
- å¤–éƒ¨é¡¾é—®æ”¯æŒ
- åŠŸèƒ½ç®€åŒ–

### 9.3 å¸‚åœºé£é™©

#### 9.3.1 ç«äº‰åŠ å‰§é£é™©

**é£é™©æè¿°**: ä¸»è¦ç«å“æ¨å‡ºç±»ä¼¼åŠŸèƒ½

**é¢„é˜²æªæ–½**:
- æŒç»­æŠ€æœ¯åˆ›æ–°
- ä¸“åˆ©ä¿æŠ¤
- ç”Ÿæ€å»ºè®¾

**åº”æ€¥é¢„æ¡ˆ**:
- åŠ é€Ÿå¼€å‘è¿›åº¦
- å·®å¼‚åŒ–ç«äº‰
- æˆ˜ç•¥åˆä½œ

---

## 10. é‡Œç¨‹ç¢‘ä¸äº¤ä»˜ç‰©

### 10.1 å¼€å‘é‡Œç¨‹ç¢‘

#### Phase 0: å‡†å¤‡æœŸ

| é‡Œç¨‹ç¢‘ | äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
|--------|--------|----------|
| **æŠ€æœ¯é€‰å‹ç¡®è®¤** | æŠ€æœ¯æ ˆç¡®å®š | Java 21 + Spring Boot + ä¾èµ–åº“é€‰å®š |
| **æ¶æ„è®¾è®¡å®Œå–„** | ç³»ç»Ÿæ¶æ„æ–‡æ¡£ | ä¸‰å±‚æ¶æ„è®¾è®¡å®Œæˆ |
| **å¼€å‘ç¯å¢ƒæ­å»º** | å¼€å‘ç¯å¢ƒ | CI/CDæµæ°´çº¿å°±ç»ª |
| **åŸºç¡€ç»„ä»¶å‡†å¤‡** | åŸºç¡€æ¡†æ¶ | é¡¹ç›®ç»“æ„æ­å»ºå®Œæˆ |

#### Phase 1: æ ¸å¿ƒå¼€å‘

| é‡Œç¨‹ç¢‘ | äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
|--------|--------|----------|
| **å¯†ç å­¦åŸºç¡€** | VRFå®ç° | é€šè¿‡æ‰€æœ‰å•å…ƒæµ‹è¯• |
| **æ•°æ®ç»“æ„** | åŸºç¡€ç»“æ„å®šä¹‰ | åºåˆ—åŒ–æµ‹è¯•é€šè¿‡ |
| **å…±è¯†å¼•æ“** | æ ¸å¿ƒå…±è¯†é€»è¾‘ | å•æœºæµ‹è¯•é€šè¿‡ |
| **ç½‘ç»œå±‚** | P2Pç½‘ç»œå®ç° | å¤šèŠ‚ç‚¹é€šä¿¡æµ‹è¯• |
| **å­˜å‚¨å±‚** | RocksDBé›†æˆ | æ•°æ®æŒä¹…åŒ–æµ‹è¯• |

#### Phase 2: æµ‹è¯•ç½‘

| é‡Œç¨‹ç¢‘ | äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
|--------|--------|----------|
| **å†…éƒ¨æµ‹è¯•ç½‘** | 10èŠ‚ç‚¹æµ‹è¯•ç½‘ | ç¨³å®šè¿è¡Œ1ä¸ªæœˆ |
| **æ€§èƒ½æµ‹è¯•** | æ€§èƒ½æµ‹è¯•æŠ¥å‘Š | TPS > 1000 |
| **å®‰å…¨å®¡è®¡** | å®¡è®¡æŠ¥å‘Š | æ— é«˜å±æ¼æ´ |
| **å…¬å¼€æµ‹è¯•ç½‘** | 50èŠ‚ç‚¹æµ‹è¯•ç½‘ | ç¤¾åŒºå‚ä¸æµ‹è¯• |

#### Phase 3: ä¸»ç½‘å‡†å¤‡

| é‡Œç¨‹ç¢‘ | äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
|--------|--------|----------|
| **ä¸»ç½‘ä»£ç ** | ç”Ÿäº§ç¯å¢ƒä»£ç  | ä»£ç å†»ç»“ |
| **èŠ‚ç‚¹æ‹›å‹Ÿ** | 50ä¸ªè¶…çº§èŠ‚ç‚¹ | èŠ‚ç‚¹éƒ¨ç½²å®Œæˆ |
| **ç”Ÿæ€å»ºè®¾** | åŸºç¡€DApp | 5ä¸ªDAppä¸Šçº¿ |

#### Phase 4: ä¸»ç½‘è¿è¥

| é‡Œç¨‹ç¢‘ | äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
|--------|--------|----------|
| **ä¸»ç½‘ä¸Šçº¿** | ç”Ÿäº§ç¯å¢ƒ | ç¨³å®šè¿è¡Œ |
| **ç”Ÿæ€å‘å±•** | ç¹è£ç”Ÿæ€ | TVL > $10M |
| **æŒç»­ä¼˜åŒ–** | æ€§èƒ½æå‡ | TPS > 2000 |

### 10.2 å…³é”®äº¤ä»˜ç‰©

#### æŠ€æœ¯æ–‡æ¡£
- [ ] ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£
- [ ] APIæ¥å£æ–‡æ¡£
- [ ] å¼€å‘è€…æŒ‡å—
- [ ] éƒ¨ç½²è¿ç»´æ‰‹å†Œ
- [ ] å®‰å…¨å®¡è®¡æŠ¥å‘Š

#### ä»£ç ä»“åº“
- [ ] æ ¸å¿ƒå…±è¯†å¼•æ“ä»£ç 
- [ ] ç½‘ç»œå±‚å®ç°ä»£ç 
- [ ] å­˜å‚¨å±‚å®ç°ä»£ç 
- [ ] RPCæ¥å£ä»£ç 
- [ ] é’±åŒ…æœåŠ¡ä»£ç 
- [ ] åŒºå—æµè§ˆå™¨ä»£ç 

#### æµ‹è¯•å·¥å…·
- [ ] å•å…ƒæµ‹è¯•å¥—ä»¶
- [ ] é›†æˆæµ‹è¯•å¥—ä»¶
- [ ] æ€§èƒ½æµ‹è¯•å·¥å…·
- [ ] å‹åŠ›æµ‹è¯•å·¥å…·
- [ ] å®‰å…¨æµ‹è¯•å·¥å…·

#### éƒ¨ç½²å·¥å…·
- [ ] Dockeré•œåƒ
- [ ] éƒ¨ç½²è„šæœ¬
- [ ] ç›‘æ§ç³»ç»Ÿ
- [ ] æ—¥å¿—ç³»ç»Ÿ
- [ ] å¤‡ä»½æ¢å¤å·¥å…·

---

## 11. å¼€å‘èµ„æº

### 11.1 æŠ€æœ¯èµ„æº

#### 11.1.1 å¼€å‘ç¯å¢ƒ

| èµ„æºç±»å‹ | è§„æ ¼ | ç”¨é€” |
|----------|------|------|
| å¼€å‘æœºå™¨ | 16æ ¸/64GB/2TB SSD | æœ¬åœ°å¼€å‘ç¯å¢ƒ |
| æµ‹è¯•æœåŠ¡å™¨ | 8æ ¸/32GB/1TB SSD | æµ‹è¯•ç½‘èŠ‚ç‚¹ |
| äº‘æœåŠ¡ | AWS/GCP | CI/CDå’Œéƒ¨ç½² |

#### 11.1.2 ç¬¬ä¸‰æ–¹æœåŠ¡

| æœåŠ¡ç±»å‹ | æä¾›å•† | ç”¨é€” |
|----------|--------|------|
| å®‰å…¨å®¡è®¡ | Trail of Bits/CertiK | ä»£ç å®‰å…¨å®¡è®¡ |
| ä»£ç æ‰˜ç®¡ | GitHub | ä»£ç ç‰ˆæœ¬ç®¡ç† |
| ç›‘æ§æœåŠ¡ | Prometheus/Grafana | ç³»ç»Ÿç›‘æ§ |
| æ–‡æ¡£æœåŠ¡ | GitBook | æŠ€æœ¯æ–‡æ¡£ |

### 11.2 å¼€å‘å·¥å…·

#### 11.2.1 å¿…éœ€å·¥å…·
- **IDE**: IntelliJ IDEA Ultimate
- **ç‰ˆæœ¬æ§åˆ¶**: Git + GitHub
- **æ„å»ºå·¥å…·**: Maven 3.8+
- **Javaç‰ˆæœ¬**: Java 21 LTS
- **å®¹å™¨**: Docker
- **ç›‘æ§**: Prometheus + Grafana

#### 11.2.2 ä»£ç è´¨é‡å·¥å…·
- **é™æ€åˆ†æ**: SpotBugs, PMD, Checkstyle
- **æµ‹è¯•è¦†ç›–ç‡**: JaCoCo
- **ä»£ç æ ¼å¼åŒ–**: Spotless
- **æ€§èƒ½åˆ†æ**: JProfiler, VisualVM

---

## 12. åç»­ç»´æŠ¤è®¡åˆ’

### 12.1 æŒç»­å¼€å‘

#### 12.1.1 åŠŸèƒ½è¿­ä»£

| ç‰ˆæœ¬ | æ—¶é—´ | ä¸»è¦åŠŸèƒ½ | å¼€å‘å‘¨æœŸ |
|------|------|----------|----------|
| v1.0 | 18ä¸ªæœˆ | åŸºç¡€å…±è¯† | 18ä¸ªæœˆ |
| v1.1 | 21ä¸ªæœˆ | æ€§èƒ½ä¼˜åŒ– | 3ä¸ªæœˆ |
| v1.2 | 24ä¸ªæœˆ | Layer2æ”¯æŒ | 3ä¸ªæœˆ |
| v2.0 | 30ä¸ªæœˆ | åˆ†ç‰‡æŠ€æœ¯ | 6ä¸ªæœˆ |
| v2.1 | 36ä¸ªæœˆ | éšç§ä¿æŠ¤ | 6ä¸ªæœˆ |

#### 12.1.2 æŠ€æœ¯å‡çº§

```java
// ç‰ˆæœ¬å…¼å®¹æ€§è®¾è®¡
package io.equiflux.node.consensus;

public interface ConsensusEngine {
    Version getVersion();
    boolean isCompatible(Version other);
    void migrateTo(Version targetVersion) throws MigrationException;
}

// å‡çº§æœºåˆ¶
package io.equiflux.node.upgrade;

@Component
public class UpgradeManager {
    private Version currentVersion;
    private final List<Version> supportedVersions;
    
    public UpgradeManager() {
        this.supportedVersions = new ArrayList<>();
    }
    
    public boolean canUpgrade(Version targetVersion) {
        return supportedVersions.contains(targetVersion);
    }
    
    public void executeUpgrade(Version targetVersion) throws UpgradeException {
        // æ‰§è¡Œå‡çº§é€»è¾‘
        this.currentVersion = targetVersion;
    }
}
```

### 12.2 ç¤¾åŒºå»ºè®¾

#### 12.2.1 å¼€å‘è€…ç”Ÿæ€

```java
// SDKå¼€å‘
package io.equiflux.node.sdk;

public class EquifluxSDK {
    private final RpcClient client;
    private final Wallet wallet;
    
    public EquifluxSDK(String rpcUrl) {
        this.client = new RpcClient(rpcUrl);
        this.wallet = new Wallet();
    }
    
    public CompletableFuture<String> sendTransaction(Transaction tx) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // å‘é€äº¤æ˜“
                return client.sendTransaction(tx);
            } catch (Exception e) {
                throw new SdkException("Failed to send transaction", e);
            }
        });
    }
}
```

#### 12.2.2 æ²»ç†æœºåˆ¶

```java
// é“¾ä¸Šæ²»ç†
package io.equiflux.node.governance;

@Component
public class Governance {
    private final List<Proposal> proposals;
    private final Map<String, VotingPower> voters;
    
    public Governance() {
        this.proposals = Collections.synchronizedList(new ArrayList<>());
        this.voters = new ConcurrentHashMap<>();
    }
    
    public ProposalId submitProposal(Proposal proposal) throws GovernanceException {
        // æäº¤ææ¡ˆ
        ProposalId id = generateProposalId();
        proposals.add(proposal);
        return id;
    }
    
    public void vote(ProposalId proposalId, Vote vote) throws GovernanceException {
        // æŠ•ç¥¨
        Optional<Proposal> proposal = proposals.stream()
            .filter(p -> p.getId().equals(proposalId))
            .findFirst();
            
        if (proposal.isPresent()) {
            proposal.get().addVote(vote);
        } else {
            throw new GovernanceException("Proposal not found");
        }
    }
}
```

### 12.3 è¿è¥ç»´æŠ¤

#### 12.3.1 ç›‘æ§ç³»ç»Ÿ

```java
// ç›‘æ§æŒ‡æ ‡
package io.equiflux.node.metrics;

@Component
public class Metrics {
    private final MeterRegistry meterRegistry;
    private final Gauge tps;
    private final Timer blockTime;
    private final Gauge nodeCount;
    private final Counter errorRate;
    
    public Metrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.tps = Gauge.builder("equiflux.tps").register(meterRegistry);
        this.blockTime = Timer.builder("equiflux.block.time").register(meterRegistry);
        this.nodeCount = Gauge.builder("equiflux.node.count").register(meterRegistry);
        this.errorRate = Counter.builder("equiflux.error.rate").register(meterRegistry);
    }
    
    public void recordBlockTime(Duration duration) {
        blockTime.record(duration);
    }
    
    public void recordError(String errorType) {
        errorRate.increment(Tags.of("error_type", errorType));
    }
}
```

#### 12.3.2 è¿ç»´å·¥å…·

```bash
#!/bin/bash
# èŠ‚ç‚¹ç®¡ç†è„šæœ¬

# å¯åŠ¨èŠ‚ç‚¹
start_node() {
    docker run -d \
        --name equiflux-node \
        -p 30333:30333 \
        -p 9933:9933 \
        -v /data/equiflux:/data \
        equiflux/node:latest
}

# åœæ­¢èŠ‚ç‚¹
stop_node() {
    docker stop equiflux-node
    docker rm equiflux-node
}

# æŸ¥çœ‹æ—¥å¿—
view_logs() {
    docker logs -f equiflux-node
}

# å¤‡ä»½æ•°æ®
backup_data() {
    tar -czf backup_$(date +%Y%m%d).tar.gz /data/equiflux
}
```

---

## æ€»ç»“

æœ¬å¼€å‘è®¡åˆ’åŸºäºEquiflux Chain v2.0 FinalæŠ€æœ¯æ–¹æ¡ˆï¼Œåˆ¶å®šäº†è¯¦ç»†çš„å¼€å‘è·¯çº¿å›¾ã€‚æ ¸å¿ƒè¦ç‚¹ï¼š

### å…³é”®æˆåŠŸå› ç´ 
1. **æŠ€æœ¯å®ç°**: å®Œå…¨é€æ˜VRFæœºåˆ¶å’Œä¸‰å±‚æ··åˆå…±è¯†æ¶æ„çš„å‡†ç¡®å®ç°
2. **æ€§èƒ½è¾¾æ ‡**: TPS â‰ˆ 1800ï¼Œå‡ºå—æ—¶é—´ 3ç§’ï¼Œç¡®è®¤æ—¶é—´ 8ç§’
3. **å®‰å…¨å¯é **: é€šè¿‡å¤šè½®å®‰å…¨å®¡è®¡ï¼Œæ— å†å²æŒ‘æˆ˜æœºåˆ¶
4. **ç”Ÿæ€å»ºè®¾**: å¸å¼•å¼€å‘è€…å’Œç”¨æˆ·å‚ä¸
5. **å•äººå¼€å‘**: é«˜æ•ˆçš„å…¨æ ˆå¼€å‘æ¨¡å¼

### æ ¸å¿ƒåˆ›æ–°
- **å®Œå…¨é€æ˜çš„VRFæœºåˆ¶**: æ‰€æœ‰è¶…çº§èŠ‚ç‚¹å¼ºåˆ¶å…¬å¼€VRFï¼ŒåŒºå—åŒ…å«æ‰€æœ‰VRFè¯æ˜
- **å®æ—¶æœ€ç»ˆæ€§**: ç¡®è®¤å³ä¸å¯é€†ï¼Œæ— éœ€å†å²æŒ‘æˆ˜
- **æ¿€åŠ±å‰15å**: é¼“åŠ±è¯šå®å…¬å¼€VRFçš„ç»æµæœºåˆ¶
- **Java 21å†…ç½®å¯†ç å­¦**: æ— éœ€å¤–éƒ¨ä¾èµ–ï¼Œå‡å°‘å®‰å…¨é£é™©

### å¼€å‘é‡ç‚¹
- **å…±è¯†å¼•æ“**: å®Œå…¨é€æ˜VRFæœºåˆ¶å®ç°
- **å¯†ç å­¦æ¨¡å—**: Java 21å†…ç½®APIé›†æˆ
- **ç½‘ç»œå±‚**: P2Pé€šä¿¡å’ŒGossipåè®®
- **å­˜å‚¨å±‚**: RocksDBé›†æˆ
- **åº”ç”¨å±‚**: RPCæ¥å£å’ŒåŸºç¡€å·¥å…·

é€šè¿‡ä¸¥æ ¼æ‰§è¡Œæœ¬è®¡åˆ’ï¼ŒEquiflux Chainæœ‰æœ›æˆä¸ºæ€§èƒ½ã€å®‰å…¨æ€§ã€å»ä¸­å¿ƒåŒ–å¹³è¡¡æœ€å¥½çš„å…¬é“¾ä¹‹ä¸€ï¼Œåœ¨åŒºå—é“¾é¢†åŸŸå æ®é‡è¦åœ°ä½ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0  
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ  
**åŸºäºæŠ€æœ¯æ–¹æ¡ˆ**: v2.0 Final (2025-10-18)  
**åˆ¶å®šäºº**: å¼€å‘è€…  

---

## é™„å½•

### A. æŠ€æœ¯å‚è€ƒ

- [EquifluxæŠ€æœ¯æ–¹æ¡ˆæ–‡æ¡£](./æŠ€æœ¯æ–¹æ¡ˆ.md)
- [Equifluxç™½çš®ä¹¦](./docs/equiflux_whitepaper.md)
- [æŠ€æœ¯å¯¹æ ‡åˆ†ææŠ¥å‘Š](./æŠ€æœ¯å¯¹æ ‡åˆ†ææŠ¥å‘Š.md)

### B. å¼€å‘å·¥å…·

- [Javaå®˜æ–¹æ–‡æ¡£](https://docs.oracle.com/en/java/)
- [Spring Bootæ–‡æ¡£](https://spring.io/projects/spring-boot)
- [Nettyæ–‡æ¡£](https://netty.io/)
- [RocksDB Javaæ–‡æ¡£](https://github.com/facebook/rocksdb/tree/main/java)

### C. ç›¸å…³é¡¹ç›®

- [Algorand](https://github.com/algorand/go-algorand)
- [Hyperledger Fabric](https://github.com/hyperledger/fabric)
- [Corda](https://github.com/corda/corda)
- [Quorum](https://github.com/ConsenSys/quorum)

---

**ç‰ˆæƒå£°æ˜**: æœ¬æ–‡æ¡£ä¸ºEquiflux Chainé¡¹ç›®å†…éƒ¨å¼€å‘è®¡åˆ’ï¼Œä»…ä¾›é¡¹ç›®å›¢é˜Ÿä½¿ç”¨ã€‚
